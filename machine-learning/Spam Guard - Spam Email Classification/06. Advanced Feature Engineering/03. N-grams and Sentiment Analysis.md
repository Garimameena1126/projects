#  Implementing More Sophisticated Feature Engineering Techniques

In this guide, we will explore more sophisticated feature engineering techniques for our email classification project. Specifically, we will focus on implementing n-grams and sentiment analysis. These techniques can help us extract more meaningful features from the email text, improving the performance of our machine learning model. Let's get started!

## 1. Understanding N-grams

N-grams are contiguous sequences of n items from a given sample of text. In the context of natural language processing, these items are typically words. By considering combinations of words, we can capture more contextual information and improve the representation of text data.

### 1.1 N-gram Generation

To generate n-grams from a text document, we can follow these steps:

1. Split the text into individual words or tokens.
2. Create n-grams by sliding a window of size n over the tokens.
3. Combine the tokens within the window to form n-grams.

Let's see an example to generate n-grams from a sentence:

```python
# Example code for generating n-grams
from nltk import ngrams

sentence = "I love to read books."

# Tokenize the sentence into words
tokens = sentence.split()

# Generate n-grams
n = 2  # Set the value of n for desired n-grams
generated_ngrams = list(ngrams(tokens, n))

print(generated_ngrams)
```

Output:
```
[('I', 'love'), ('love', 'to'), ('to', 'read'), ('read', 'books.')]
```

In the example above, we set n=2, so the code generates bi-grams (2-grams) from the sentence.

### 1.2 Applying N-grams to Text Data

To apply n-grams to our email classification task, we need to create n-gram features from the email text. Here's an example of how we can incorporate n-grams into our preprocessing pipeline:

```python
# Example code for applying n-grams to text data
from sklearn.feature_extraction.text import CountVectorizer

# Assuming 'preprocessed_emails' contains preprocessed email text

n = 2  # Set the value of n for desired n-grams

# Create a CountVectorizer instance with n-gram range
vectorizer = CountVectorizer(ngram_range=(n, n))

# Fit the vectorizer on the preprocessed email text
vectorizer.fit(preprocessed_emails)

# Transform the preprocessed email text into n-gram features
ngram_features = vectorizer.transform(preprocessed_emails)

print(ngram_features)
```

Output:
```
(0, 0)        1
(0, 1)        1
(0, 2)        1
(1, 1)        1
(1, 2)        1
...
```

In the code above, we use the `CountVectorizer` class from scikit-learn to convert the preprocessed email text into a matrix of n-gram features. The `ngram_range` parameter is set to `(n, n)` to generate n-grams of size n.

## 2. Performing Sentiment Analysis

Sentiment analysis is the process of determining the emotional tone of a given text. In the context of email classification, sentiment analysis can provide additional information about the sentiment expressed in the email, which can be useful as a feature.

### 2.1 Sentiment Analysis using pre-trained models

One way to perform sentiment analysis is by utilizing pre-trained models or libraries that provide sentiment analysis capabilities. Let's look at an example using the `nltk` library:

```python
# Example code for performing sentiment analysis using

 nltk
import nltk
from nltk.sentiment import SentimentIntensityAnalyzer

nltk.download('vader_lexicon')

# Assuming 'preprocessed_emails' contains preprocessed email text

# Initialize the sentiment analyzer
sentiment_analyzer = SentimentIntensityAnalyzer()

# Perform sentiment analysis on preprocessed emails
sentiment_scores = []

for email in preprocessed_emails:
    sentiment_score = sentiment_analyzer.polarity_scores(email)
    sentiment_scores.append(sentiment_score)

print(sentiment_scores)
```

Output:
```
[{'neg': 0.0, 'neu': 0.198, 'pos': 0.802, 'compound': 0.9274},
 {'neg': 0.113, 'neu': 0.587, 'pos': 0.3, 'compound': 0.6468},
 ...
]
```

In the example above, we use the `SentimentIntensityAnalyzer` from the `nltk.sentiment` module to analyze the sentiment of preprocessed emails. The method `polarity_scores()` returns a dictionary containing sentiment scores for each email.

### 2.2 Creating Sentiment Features

To incorporate sentiment analysis results as features, we can consider the sentiment scores generated by the sentiment analyzer. These scores can be used as numerical features or converted into categorical labels based on specific thresholds.

Here's an example of how we can create sentiment features:

```python
# Example code for creating sentiment features
import numpy as np

# Assuming 'sentiment_scores' contains sentiment scores for each email

# Extract compound sentiment scores
compound_scores = [score['compound'] for score in sentiment_scores]

# Convert compound scores into categorical labels
threshold = 0.5
sentiment_labels = np.where(np.array(compound_scores) >= threshold, 'positive', 'negative')

print(sentiment_labels)
```

Output:
```
['positive', 'positive', 'negative', 'positive', ...]
```

In the code above, we extract the compound sentiment scores from the sentiment analysis results and convert them into categorical labels based on a threshold value. Emails with a compound score above or equal to the threshold are labeled as 'positive,' while those below the threshold are labeled as 'negative.'
